/* 
Решите классическую проблему «поставщик – потребитель» с использованием описанных 
в лабораторной работе средств синхронизации.

Постановка задачи:
Один поток производит данные, другой поток их потребляет. В промежуток времени 
между изготовлением и потреблением данные хранятся в буфере.

Пример использования: Конвейер команд в Unix.

Исходные данные:
Данные хранятся в циклическом буфере. Циклический буфер описывается некоторой 
обла-стью памяти, указателем начала данных и указателем конца данных. 
Поток-поставщик запи-сывает данные в конец буфера, поток-потребитель считывает 
их с начала буфера. После за-писи или чтения соответствующим образом меняются 
указатели начала и конца.
Операции чтения/записи должны быть выполнены как взаимоисключающие.
Если операция чтения выполняется над пустым буфером (указатель начала = указатель кон-ца), 

поток-потребитель должен быть заблокирован на условной переменной до тех пор, пока 
поток-поставщик не запишет в буфер какие-нибудь данные. Если операция записи выполня-ется 
над полным буфером, поток-поставщик должен также быть заблокирован на условной переменной 
до тех пор, пока поток-потребитель не считает из буфера какие-нибудь данные.

Размер буфера – не менее 10 символов.

Поток-поставщик и поток-потребитель работают в бесконечном цикле.
Поток-поставщик производит по одному символу в последовательности 0,1,2...9,0,1,... 
и за-писывает его в буфер через случайный интервал времени 0,5 – 2 сек.
Поток-потребитель считывает по одному символу через случайный интервал времени 
0,5 – 2 сек из буфера и выводит их на экран в виде сообщений (например, Символ 0, Символ 1,...)

Каждый поток совершая операцию с буфером выводит на экран информацию о текущем состоянии 
буфера до и после операции, тип операции, символ, состояние условной перемен-ной.
 */




// После "считывания" (просто сдвиг) и записи указатели всегда сдвигаются на ячейку далее

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Максимальный размер буфера
#define MAX_SIZE 10

pthread_mutex_t my_sync;
pthread_cond_t rx; // сигнал об освобождении места в переполненном буфере
pthread_cond_t rx1; // сигнал о записи в пустой буфер
 
// Объявление структуры данных "Кольцевой буфер"
typedef struct
{
	int data[MAX_SIZE]; 
	int* first; // указатель на первый элемент буфера
	int* last; // указатель на последний элемент буфера
	int size; // размер буфера, cвоего рода семафор: при записи он увеличивается, при чтении уменьшается. Исчисляется от 0 до MAX_SIZE
} CircularBuffer;

// Инициализация: указатель на первый элемент буфера = последнему, размер буфера = 0
void Init_CircularBuffer(CircularBuffer *cb)
{
	cb->first = &cb->data[0];
	cb->last = &cb->data[0];
	cb->size = 0; 
} 


// Вывод всех элементов буфера на настоящий момент от начала до конца (слева-направо)
void PrintCurrBuff (CircularBuffer *cb)
{
	int* a;
	printf ("Данные в буфере: ");
	if (cb->size != 0) 
	{		
		a=cb->first ;
		while (a!=cb->last)	
		{
			printf ("%d ",*a);
			if (a==&cb->data[MAX_SIZE-1]) // т.е. с другого конца начинается 	1	1	0	0	5
				a = &cb->data[0] ;
			else
				a++;
		}
		printf ("\n\n");
	}
	else 
	if (cb->size == 0) 
	{
		printf (" пусто\n\n");
	}
	
}



//Поток-поставщик
void* Provider(CircularBuffer *cb)
{	
	int i=0;
	while (1)
	{ 			
		usleep((rand()%151 + 50)*10000); // от 0.5 до 2 сек
		
		pthread_mutex_lock (&my_sync);
		
		// Запись в буфер
		*cb->last = i; // запись числа от 0 до 9 в конец буфера
		cb->size = cb->size + 1; // размер буфера увеличился 
		printf ("Записан символ %d.		Текущий размер буфера: %d элемент(а,ов)\n",i,cb->size);
		
		// Если буфер заполнен(а мы в последний элемент выше уже записали), то
		while (cb->size == MAX_SIZE) // ожидание от усл. переменной сигнала, что в буфере освободилось место
			pthread_cond_wait(&rx, &my_sync); // ждём сигнала от усл. переменной об изменении cb->size		

		//Перевод указателя на конец буфера
		if (cb->last == &cb->data[MAX_SIZE-1]) // если указатель на последний элемент достиг конца массива (а мы туда записали уже), то переводим в начало
		{
			cb->last = &cb->data[0]; // перевод указателя 
		}
		
		else 
		if (cb->last != &cb->data[MAX_SIZE-1])// Если буфер не заполнен, то
			cb->last = cb->last + 1; // сдвиг указателя на 1, т.е. он становиться адресом следующего элемента массива (буфера)
		
		PrintCurrBuff(cb);

		// вывод значений указателей
	///	printf("\ncb->last= %d\ncb->first= %d\n&cb->data[0]= %d\n&cb->data[MAX_SIZE]= %d\n\n",cb->last,cb->first,&cb->data[0],&cb->data[MAX_SIZE]);
			
		// Если до записи буфер был пуст
		if (cb->size-1==0) 
			pthread_cond_signal (&rx1); // посылаем сигнал усл. переменной, что cb->size уже не ноль	
		
		pthread_mutex_unlock (&my_sync);
		
		if (i==MAX_SIZE-1)
			i = 0;
		else 
			i++;
	}
	
}



// Поток-потребитель
void* Consumer (CircularBuffer *cb)
{
	while (1)
	{
		usleep((rand()%151 + 50)*10000); // от 0.5 до 2 сек
		
		pthread_mutex_lock (&my_sync);
		
		
		// Если буфер пуст 
		while (cb->size == 0) // ожидание от усл. переменной сигнала, что в буфере освободилось место
			pthread_cond_wait(&rx1, &my_sync); // ждём сигнала от усл. переменной об изменении cb->size	
		
		// Прочтение из буфера
		if (cb->first == &cb->data[MAX_SIZE-1]) // если чтение из последнего элемента массива
			cb->first = &cb->data[0]; // // возвращаем указатель начала в "начало"
		else
		if (cb->first != &cb->data[MAX_SIZE-1])
			cb->first = cb->first + 1; // сдвигаем указатель начала
		
		cb->size = cb->size - 1; // размер буфера уменьшился
		printf ("Прочитан символ %d.	Текущий размер буфера: %d элемент(а,ов)\n",*(cb->first-1),cb->size);
		
		PrintCurrBuff(cb);///
		
		if (cb->size+1 == MAX_SIZE) // Если буфер был заполнен до прочтения , то
			pthread_cond_signal (&rx); // посылаем сигнал разблокировки
		
		pthread_mutex_unlock (&my_sync);
	}
}


//============================================================
int main(){

pthread_t tid,tid1;
pthread_attr_t attr,attr1;
pthread_attr_init (&attr); pthread_attr_init (&attr1);
pthread_mutex_init (&my_sync, NULL);
pthread_cond_init (&rx, NULL); pthread_cond_init (&rx1, NULL);

// Объявление кольцевого буфера
CircularBuffer cb;

// Инициализация: указатель на первый элемент буфера = последнему, размер буфера = 0
Init_CircularBuffer(&cb);

// Вывод всех элементов буфера на настоящий момент
PrintCurrBuff (&cb);

// вызываем два потока и ожидаем их завершения в главном
pthread_create(&tid, &attr, Provider, &cb);

pthread_create(&tid1, &attr1, Consumer, &cb);

pthread_join(tid,NULL);
pthread_join(tid1,NULL);

}




